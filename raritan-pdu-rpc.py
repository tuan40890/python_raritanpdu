#!/usr/bin/env python3
import sys
import os
import json
import datetime
import concurrent.futures
import pandas as pd
from cryptography.fernet import Fernet
from raritan import rpc
import raritan.rpc.pdumodel as pdumodel
import raritan.rpc.net as net_rpc
import raritan.rpc.datetime as ntp


# define global variables
PDU_IP_ADDRESSES = "pdu_ip.txt"
KEY_FILE = "pdu_key.key"
CREDS_FILE = "pdu_key.enc"


def load_creds():
    '''
    Load the credentials from the "pdu_key.key" and the "pdu_key.enc" files that was generated by the "pdu_key.py" file
    '''
    try:

        # open KEY_FILE and CREDS_FILE in read & binary mode "rb" 
        key = open(KEY_FILE, "rb").read()

        # encrypt data using Fernet and use Fernet's method to decrypt data
        data = Fernet(key).decrypt(open(CREDS_FILE, "rb").read())

        # data is still the form of bytes, decode it into strings
        str_creds = json.loads(data.decode())

        # extract the str_creds to return the values
        return str_creds["username"], str_creds["password"]
    
    except Exception as e:

        # if there's an error, capture the error and print it
        print(f"Credential error: {e}")

        # if there's an error, stop running the script
        sys.exit(1)


def pdu_retrieve_info(ip, user, password):
    '''
    Run script to retrieve info from all PDUs using the IP addresses listed in the pdu_ip.txt
    '''
    # set an empty list to queue all output sections, we will join all the output after
    display_output = []

    try:
        # create an agent to point to
        agent = rpc.Agent("https", ip, user, password, disable_certificate_verification=True)
        network = net_rpc.Net("/net", agent)
        pdu = pdumodel.Pdu("/model/pdu/0", agent)
        pdu_inlet = pdumodel.Inlet("/model/inlet/0", agent)
        ntpservers = ntp.DateTime("/datetime", agent)

        # set variables to retrieve PDU data
        retrieve_hostname = pdu.getSettings().name
        retrieve_manufacturer = pdu.getMetaData().nameplate.manufacturer
        retrieve_model = pdu.getMetaData().nameplate.model
        retrieve_inlet = pdu_inlet.getMetaData().plugType[5:]
        retrieve_serial = pdu.getMetaData().nameplate.serialNumber
        retrieve_fw_ver = pdu.getMetaData().fwRevision

        # add the output to the display_output queue list
        display_output.append("[DEVICE INFO]\n"
        f"Hostname : {retrieve_hostname}\n"
        f"Manufacturer : {retrieve_manufacturer}\n"
        f"Model : {retrieve_model}\n"
        f"Inlet Type : {retrieve_inlet}\n"
        f"Serial Number : {retrieve_serial}\n"
        f"FW Revision : {retrieve_fw_ver}\n"
        "-------------------------------------------------------------------------------\n")

        # set variables to retrieve network data
        retrieve_net = network.getSettings()
        retrieve_eth_addr = retrieve_net.ifMap.get("eth0").ipv4.staticAddrCidr.addr
        retrieve_eth_prefixLen = retrieve_net.ifMap.get("eth0").ipv4.staticAddrCidr.prefixLen
        retrieve_eth_gw = retrieve_net.ifMap.get("eth0").ipv4.staticDefaultGatewayAddr
        retrieve_dns = retrieve_net.common.dns.serverAddrs
        retrieve_ntp = ntpservers.getActiveNtpServers()

        # add the output to the display_output queue list
        display_output.append("[NETWORK INFO]\n"
        f"IP Address : {retrieve_eth_addr}/{retrieve_eth_prefixLen}\n"
        f"Gateway : {retrieve_eth_gw}\n"
        f"DNS : {retrieve_dns}\n"
        f"NTP : {retrieve_ntp}\n"
        "-------------------------------------------------------------------------------\n")

        # set an empty list to append data that will be genereated by the for loop
        outlet_data = []

        # loop over each outlet to obtain settings
        for outlet in pdu.getOutlets():

            # set variables to retrieve outlet data
            retrieve_outlet_watts = int(outlet.getSensors().activePower.getReading().value)
            retrieve_outlet_label = outlet.getMetaData().label
            retrieve_outlet_receptacletype = outlet.getMetaData().receptacleType[-3:]
            retrieve_outlet_status = str(outlet.getState().powerState).split("_")[-1]
            retrieve_outlet_description = outlet.getSettings().name

            # add data to the existing empty outlet_data list
            outlet_data.append(
                {
                    "Watts": retrieve_outlet_watts,
                    "Outlet": retrieve_outlet_label,
                    "Type": retrieve_outlet_receptacletype,
                    "Status": retrieve_outlet_status,
                    "Description": retrieve_outlet_description
                }
            )

        if outlet_data:
            # create DataFrame directly from the outlet_data dictionaries
            df = pd.DataFrame(outlet_data)
            display_output.append("[OUTLET INFO]")

            # tell Pandas not to print the DataFrame's index (the row numbers) in the output
            # also align the column headers in the center
            display_output.append(df.to_string(justify='center', index=False))
        else:
            display_output.append("\tNo outlets found.")

        # display inlet's current active power
        inlet_power = pdu.getInlets()[-1].getSensors().activePower.getReading().value
        display_output.append(f"----------------------------\nTotal Active Power: {inlet_power:.2f} W\n")
        display_output.append("-------------------------------------------------------------------------------\n")

        # name the output variable and append output data to it
        output_file_name = f"pdu_{retrieve_hostname}.txt"
        display_output.append(f"PDU info is exported to '{output_file_name}'\n\n")

    except Exception as e:
        display_output.append(f"\nError for {retrieve_hostname} with IP {ip}: {e}\n")

    # join all the queued output
    joining_output = "\n".join(display_output)
    
    # set up a safety mechanism if error occurs so script continues to run
    try:
        with open(output_file_name, "w") as f:
            f.write(joining_output)
    except Exception as e:
        joining_output += f"\nCRITICAL: cannot write {output_file_name}: {e}\n"
    return joining_output


if __name__ == "__main__":
    # all the print statements here will be displayed in the terminal and are not saved as a separate file
    # start timer before running the script to estimate how long the script takes to complete
    script_starting_time = datetime.datetime.now()
    print(f"\nScript started at {script_starting_time:%H:%M:%S} on {script_starting_time:%m-%d-%Y}\n")

    # load the credentials to be used for concurrency after
    user, password = load_creds()
    # check if file pdu_ip.txt exists in the same directory, a failure occurs if it's not, stop running the script
    if not os.path.exists(PDU_IP_ADDRESSES):
        print(f"Missing '{PDU_IP_ADDRESSES}'")
        sys.exit(1)

    # use list comprehension to include only the stripped IP addresses
    ip_addresses = [each_line.strip() for each_line in open(PDU_IP_ADDRESSES) if each_line.strip()]
    if not ip_addresses:
        print("No IPs found. Exiting.")
        # if no IPs found, and there's no error, stop running the script
        sys.exit(0)

    print(f"Starting PDU information retrieval for {len(ip_addresses)} PDUs...\n")
    # deploy ThreadPoolExecutor to use multi-threading to achieve concurrency
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor_object:
        for future_object in concurrent.futures.as_completed(
            executor_object.submit(pdu_retrieve_info, ip, user, password) for ip in ip_addresses
        ):
            # future_object.result() is the result that came from the pdu_retrieve_info()
            print(future_object.result(), end="")

    script_ending_time = datetime.datetime.now()
    duration = int((script_ending_time - script_starting_time).total_seconds())
    hour, remainder = divmod(duration, 3600)
    minute, second = divmod(remainder, 60)

    print("Completed.")
    print(f"\nScript ended at {script_ending_time:%H:%M:%S} on {script_ending_time:%m-%d-%Y}")
    print(f"Total script runtime: {hour:02}:{minute:02}:{second:02}")
