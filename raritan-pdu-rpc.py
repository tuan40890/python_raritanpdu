#!/usr/bin/env python3
import sys
import os
import json
import datetime
import concurrent.futures
import pandas as pd
from cryptography.fernet import Fernet
from raritan import rpc
import raritan.rpc.pdumodel as pdumodel
import raritan.rpc.net as net_rpc
import raritan.rpc.datetime as ntp

# define global variables
PDU_IP_ADDRESSES = "pdu_ip.txt"
KEY_FILE = "pdu_key.key"
CREDS_FILE = "pdu_key.enc"

def load_creds():
    '''
    Load the credentials from the "pdu_key.key" and the "pdu_key.enc" files that was generated by the "pdu_key.py" file
    '''
    try:
        # open KEY_FILE and CREDS_FILE in read & binary mode "rb" 
        key = open(KEY_FILE, "rb").read()
        # encrypt data using Fernet and use Fernet's method to decrypt data
        data = Fernet(key).decrypt(open(CREDS_FILE, "rb").read())
        # data is still the form of bytes, decode it into strings
        str_creds = json.loads(data.decode())
        # extract the str_creds to return the values
        return str_creds["username"], str_creds["password"]
    except Exception as e:
        # if there's an error, capture the error and print it
        print(f"Credential error: {e}")
        # if there's an error, stop running the script
        sys.exit(1)


def pdu_retrieve_info(ip, user, password):
    '''
    Run script to retrieve info from all PDUs using the IP addresses listed in the pdu_ip.txt
    '''
    starting_out = []
    ip_with_underscore = ip.replace(".", "_")
    fn = f"pdu_info_{ip_with_underscore}.txt"
    try:
        agent = rpc.Agent("https", ip, user, password, disable_certificate_verification=True)
        network = net_rpc.Net("/net", agent)
        pdu = pdumodel.Pdu("/model/pdu/0", agent)
        pdu_inlet = pdumodel.Inlet("/model/inlet/0", agent)
        ntpservers = ntp.DateTime("/datetime", agent)

        retrieve_hostname = pdu.getSettings()
        retrieve_nameplate = pdu.getMetaData()
        retrieve_fw_ver = pdu.getMetaData()
        retrieve_net = network.getSettings()
        retrieve_inlet = pdu_inlet.getMetaData()
        retrieve_eth = retrieve_net.ifMap.get("eth0")
        retrieve_dns = retrieve_net.common.dns.serverAddrs
        retrieve_ntp = ntpservers.getActiveNtpServers()

        fn = f"pdu_info_{retrieve_hostname.name}.txt"
        starting_out.append(f"""
[DEVICE INFO]
    Hostname: {retrieve_hostname.name}
    Manufacturer: {retrieve_nameplate.nameplate.manufacturer}
    Model: {retrieve_nameplate.nameplate.model}
    Inlet Type: {retrieve_inlet.plugType[5:]}
    SN: {retrieve_nameplate.nameplate.serialNumber}
    FW Revision: {retrieve_fw_ver.fwRevision}
-------------------------------------------------------------------------------
[NETWORK INFO]
    IP Address: {retrieve_eth.ipv4.staticAddrCidr.addr}/{retrieve_eth.ipv4.staticAddrCidr.prefixLen}
    Gateway: {retrieve_eth.ipv4.staticDefaultGatewayAddr}
    DNS: {retrieve_dns}
    NTP: {retrieve_ntp}
-------------------------------------------------------------------------------
[OUTLET INFO]""")
        inlets = pdu.getInlets()
        inlet_power = (
            int(inlets[-1].getSensors().activePower.getReading().value) if inlets else 0
        )

        rows = []
        for o in pdu.getOutlets():
            rows.append(
                {
                    "Watts": int(o.getSensors().activePower.getReading().value),
                    "Outlet": o.getMetaData().label,
                    "Type": o.getMetaData().receptacleType[-3:],
                    "Status": str(o.getState().powerState).split("_")[-1],
                    "Name": o.getSettings().name,
                }
            )

        pd.set_option("display.colheader_justify", "left")
        if rows:
            df = pd.DataFrame(
                rows, columns=["Watts", "Outlet", "Type", "Status", "Name"]
            )
            starting_out.append(df.to_string(index=False, justify="left"))
        else:
            starting_out.append("\tNo outlets found.")

        starting_out.append(f"""----------------------------
Total Active Power: {inlet_power} W
-------------------------------------------------------------------------------
PDU information for {ip} saved to '{fn}'

""")
    except Exception as e:
        starting_out.append(f"\nError for {ip}: {e}\n")

    txt = "\n".join(starting_out)
    try:
        with open(fn, "w") as f:
            f.write(txt)
    except Exception as e:
        txt += f"\nCRITICAL: cannot write {fn}: {e}\n"
    return txt


if __name__ == "__main__":
    # all the print statements here will be displayed in the terminal and are not saved as a separate file
    # start timer before running the script to estimate how long the script takes to complete
    script_starting_time = datetime.datetime.now()
    print(f"\nScript started at {script_starting_time:%H:%M:%S} on {script_starting_time:%m-%d-%Y}\n")
    # load the credentials to be used for concurrency after
    user, password = load_creds()
    # check if file pdu_ip.txt exists in the same directory, a failure occurs if it's not, stop running the script
    if not os.path.exists(PDU_IP_ADDRESSES):
        print(f"Missing '{PDU_IP_ADDRESSES}'")
        sys.exit(1)
    # use list comprehension to include only the stripped IP addresses
    ip_addresses = [each_line.strip() for each_line in open(PDU_IP_ADDRESSES) if each_line.strip()]
    if not ip_addresses:
        print("No IPs found. Exiting.")
        # if no IPs found, and there's no error, stop running the script
        sys.exit(0)
    print(f"Starting PDU information retrieval for {len(ip_addresses)} PDUs...")
    # deploy ThreadPoolExecutor to use multi-threading to achieve concurrency
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor_object:
        for future_object in concurrent.futures.as_completed(
            executor_object.submit(pdu_retrieve_info, ip, user, password) for ip in ip_addresses
        ):
            # future_object.result() is the result that came from the pdu_retrieve_info()
            print(future_object.result(), end="")
    script_ending_time = datetime.datetime.now()
    duration = int((script_ending_time - script_starting_time).total_seconds())
    hour, remainder = divmod(duration, 3600)
    minute, second = divmod(remainder, 60)
    print("Completed.")
    print(f"\nScript ended at {script_ending_time:%H:%M:%S} on {script_ending_time:%m-%d-%Y}\n")
    print(f"Total script runtime: {hour:02}:{minute:02}:{second:02}")
